[4mGIT-RESET[24m(1)                         Git Manual                         [4mGIT-RESET[24m(1)

[1mNAME[0m
       git-reset - Reset current HEAD to the specified state

[1mSYNOPSIS[0m
       [4mgit[24m [4mreset[24m [-q] [<tree-ish>] [--] <pathspec>...
       [4mgit[24m [4mreset[24m [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]
       [4mgit[24m [4mreset[24m (--patch | -p) [<tree-ish>] [--] [<pathspec>...]
       [4mgit[24m [4mreset[24m [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]

[1mDESCRIPTION[0m
       In the first three forms, copy entries from [1m<tree-ish> [22mto the index. In the
       last form, set the current branch head ([1mHEAD[22m) to [1m<commit>[22m, optionally
       modifying index and working tree to match. The [1m<tree-ish>[22m/[1m<commit> [22mdefaults
       to [1mHEAD [22min all forms.

       [4mgit[24m [4mreset[24m [-q] [<tree-ish>] [--] <pathspec>..., [4mgit[24m [4mreset[24m [-q]
       [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]
           These forms reset the index entries for all paths that match the
           [1m<pathspec> [22mto their state at [1m<tree-ish>[22m. (It does not affect the working
           tree or the current branch.)

           This means that [1mgit reset <pathspec> [22mis the opposite of [1mgit add[0m
           [1m<pathspec>[22m. This command is equivalent to [1mgit restore[0m
           [1m[--source=<tree-ish>] --staged <pathspec>...[22m.

           After running [1mgit reset <pathspec> [22mto update the index entry, you can use
           [1mgit-restore[22m(1) to check the contents out of the index to the working
           tree. Alternatively, using [1mgit-restore[22m(1) and specifying a commit with
           [1m--source[22m, you can copy the contents of a path out of a commit to the
           index and to the working tree in one go.

       [4mgit[24m [4mreset[24m (--patch | -p) [<tree-ish>] [--] [<pathspec>...]
           Interactively select hunks in the difference between the index and
           [1m<tree-ish> [22m(defaults to [1mHEAD[22m). The chosen hunks are applied in reverse to
           the index.

           This means that [1mgit reset -p [22mis the opposite of [1mgit add -p[22m, i.e. you can
           use it to selectively reset hunks. See the ‚ÄúInteractive Mode‚Äù section of
           [1mgit-add[22m(1) to learn how to operate the [1m--patch [22mmode.

       [4mgit[24m [4mreset[24m [<mode>] [<commit>]
           This form resets the current branch head to [1m<commit> [22mand possibly updates
           the index (resetting it to the tree of [1m<commit>[22m) and the working tree
           depending on [1m<mode>[22m. Before the operation, [1mORIG_HEAD [22mis set to the tip of
           the current branch. If [1m<mode> [22mis omitted, defaults to [1m--mixed[22m. The [1m<mode>[0m
           must be one of the following:

           --soft
               Does not touch the index file or the working tree at all (but resets
               the head to [1m<commit>[22m, just like all modes do). This leaves all your
               changed files "Changes to be committed", as [1mgit status [22mwould put it.

           --mixed
               Resets the index but not the working tree (i.e., the changed files
               are preserved but not marked for commit) and reports what has not
               been updated. This is the default action.

               If [1m-N [22mis specified, removed paths are marked as intent-to-add (see
               [1mgit-add[22m(1)).

           --hard
               Resets the index and working tree. Any changes to tracked files in
               the working tree since [1m<commit> [22mare discarded. Any untracked files or
               directories in the way of writing any tracked files are simply
               deleted.

           --merge
               Resets the index and updates the files in the working tree that are
               different between [1m<commit> [22mand [1mHEAD[22m, but keeps those which are
               different between the index and working tree (i.e. which have changes
               which have not been added). If a file that is different between
               [1m<commit> [22mand the index has unstaged changes, reset is aborted.

               In other words, [1m--merge [22mdoes something like a [1mgit read-tree -u -m[0m
               [1m<commit>[22m, but carries forward unmerged index entries.

           --keep
               Resets index entries and updates files in the working tree that are
               different between [1m<commit> [22mand [1mHEAD[22m. If a file that is different
               between [1m<commit> [22mand [1mHEAD [22mhas local changes, reset is aborted.

           --[no-]recurse-submodules
               When the working tree is updated, using --recurse-submodules will
               also recursively reset the working tree of all active submodules
               according to the commit recorded in the superproject, also setting
               the submodules' HEAD to be detached at that commit.

       See "Reset, restore and revert" in [1mgit[22m(1) for the differences between the
       three commands.

[1mOPTIONS[0m
       -q, --quiet
           Be quiet, only report errors.

       --refresh, --no-refresh
           Refresh the index after a mixed reset. Enabled by default.

       --pathspec-from-file=<file>
           Pathspec is passed in [1m<file> [22minstead of commandline args. If [1m<file> [22mis
           exactly [1m- [22mthen standard input is used. Pathspec elements are separated by
           LF or CR/LF. Pathspec elements can be quoted as explained for the
           configuration variable [1mcore.quotePath [22m(see [1mgit-config[22m(1)). See also
           [1m--pathspec-file-nul [22mand global [1m--literal-pathspecs[22m.

       --pathspec-file-nul
           Only meaningful with [1m--pathspec-from-file[22m. Pathspec elements are
           separated with NUL character and all other characters are taken literally
           (including newlines and quotes).

       --
           Do not interpret any more arguments as options.

       <pathspec>...
           Limits the paths affected by the operation.

           For more details, see the [4mpathspec[24m entry in [1mgitglossary[22m(7).

[1mEXAMPLES[0m
       Undo add

               $ edit                                     [1m(1)[0m
               $ git add frotz.c filfre.c
               $ mailx                                    [1m(2)[0m
               $ git reset                                [1m(3)[0m
               $ git pull git://info.example.com/ nitfol  [1m(4)[0m

            [1m1. [22mYou are happily working on something, and find the changes in
               these files are in good order. You do not want to see them when
               you run [1mgit diff[22m, because you plan to work on other files and
               changes with these files are distracting.
            [1m2. [22mSomebody asks you to pull, and the changes sound worthy of
               merging.
            [1m3. [22mHowever, you already dirtied the index (i.e. your index does
               not match the [1mHEAD [22mcommit). But you know the pull you are going
               to make does not affect [1mfrotz.c [22mor [1mfilfre.c[22m, so you revert the
               index changes for these two files. Your changes in working tree
               remain there.
            [1m4. [22mThen you can pull and merge, leaving [1mfrotz.c [22mand [1mfilfre.c[0m
               changes still in the working tree.

       Undo a commit and redo

               $ git commit ...
               $ git reset --soft HEAD^      [1m(1)[0m
               $ edit                        [1m(2)[0m
               $ git commit -a -c ORIG_HEAD  [1m(3)[0m

            [1m1. [22mThis is most often done when you remembered what you just
               committed is incomplete, or you misspelled your commit message,
               or both. Leaves working tree as it was before "reset".
            [1m2. [22mMake corrections to working tree files.
            [1m3. [22m"reset" copies the old head to [1m.git/ORIG_HEAD[22m; redo the commit
               by starting with its log message. If you do not need to edit
               the message further, you can give [1m-C [22moption instead.

               See also the [1m--amend [22moption to [1mgit-commit[22m(1).

       Undo a commit, making it a topic branch

               $ git branch topic/wip          [1m(1)[0m
               $ git reset --hard HEAD~3       [1m(2)[0m
               $ git switch topic/wip          [1m(3)[0m

            [1m1. [22mYou have made some commits, but realize they were premature to
               be in the [1mmaster [22mbranch. You want to continue polishing them in
               a topic branch, so create [1mtopic/wip [22mbranch off of the current
               [1mHEAD[22m.
            [1m2. [22mRewind the master branch to get rid of those three commits.
            [1m3. [22mSwitch to [1mtopic/wip [22mbranch and keep working.

       Undo commits permanently

               $ git commit ...
               $ git reset --hard HEAD~3   [1m(1)[0m

            [1m1. [22mThe last three commits ([1mHEAD[22m, [1mHEAD^[22m, and [1mHEAD~2[22m) were bad and
               you do not want to ever see them again. Do [1mnot [22mdo this if you
               have already given these commits to somebody else. (See the
               "RECOVERING FROM UPSTREAM REBASE" section in [1mgit-rebase[22m(1) for
               the implications of doing so.)

       Undo a merge or pull

               $ git pull                         [1m(1)[0m
               Auto-merging nitfol
               CONFLICT (content): Merge conflict in nitfol
               Automatic merge failed; fix conflicts and then commit the result.
               $ git reset --hard                 [1m(2)[0m
               $ git pull . topic/branch          [1m(3)[0m
               Updating from 41223... to 13134...
               Fast-forward
               $ git reset --hard ORIG_HEAD       [1m(4)[0m

            [1m1. [22mTry to update from the upstream resulted in a lot of conflicts;
               you were not ready to spend a lot of time merging right now, so
               you decide to do that later.
            [1m2. [22m"pull" has not made merge commit, so [1mgit reset --hard [22mwhich is
               a synonym for [1mgit reset --hard HEAD [22mclears the mess from the
               index file and the working tree.
            [1m3. [22mMerge a topic branch into the current branch, which resulted in
               a fast-forward.
            [1m4. [22mBut you decided that the topic branch is not ready for public
               consumption yet. "pull" or "merge" always leaves the original
               tip of the current branch in [1mORIG_HEAD[22m, so resetting hard to it
               brings your index file and the working tree back to that state,
               and resets the tip of the branch to that commit.

       Undo a merge or pull inside a dirty working tree

               $ git pull                         [1m(1)[0m
               Auto-merging nitfol
               Merge made by recursive.
                nitfol                |   20 +++++----
                ...
               $ git reset --merge ORIG_HEAD      [1m(2)[0m

            [1m1. [22mEven if you may have local modifications in your working tree,
               you can safely say [1mgit pull [22mwhen you know that the change in
               the other branch does not overlap with them.
            [1m2. [22mAfter inspecting the result of the merge, you may find that the
               change in the other branch is unsatisfactory. Running [1mgit reset[0m
               [1m--hard ORIG_HEAD [22mwill let you go back to where you were, but it
               will discard your local changes, which you do not want.  [1mgit[0m
               [1mreset --merge [22mkeeps your local changes.

       Interrupted workflow
           Suppose you are interrupted by an urgent fix request while you are in the
           middle of a large change. The files in your working tree are not in any
           shape to be committed yet, but you need to get to the other branch for a
           quick bugfix.

               $ git switch feature  ;# you were working in "feature" branch and
               $ work work work      ;# got interrupted
               $ git commit -a -m "snapshot WIP"                 [1m(1)[0m
               $ git switch master
               $ fix fix fix
               $ git commit ;# commit with real log
               $ git switch feature
               $ git reset --soft HEAD^ ;# go back to WIP state  [1m(2)[0m
               $ git reset                                       [1m(3)[0m

            [1m1. [22mThis commit will get blown away so a throw-away log message is
               OK.
            [1m2. [22mThis removes the [4mWIP[24m commit from the commit history, and sets
               your working tree to the state just before you made that
               snapshot.
            [1m3. [22mAt this point the index file still has all the WIP changes you
               committed as [4msnapshot[24m [4mWIP[24m. This updates the index to show your
               WIP files as uncommitted.

               See also [1mgit-stash[22m(1).

       Reset a single file in the index
           Suppose you have added a file to your index, but later decide you do not
           want to add it to your commit. You can remove the file from the index
           while keeping your changes with git reset.

               $ git reset -- frotz.c                      [1m(1)[0m
               $ git commit -m "Commit files in index"     [1m(2)[0m
               $ git add frotz.c                           [1m(3)[0m

            [1m1. [22mThis removes the file from the index while keeping it in the
               working directory.
            [1m2. [22mThis commits all other changes in the index.
            [1m3. [22mAdds the file to the index again.

       Keep changes in working tree while discarding some previous commits
           Suppose you are working on something and you commit it, and then you
           continue working a bit more, but now you think that what you have in your
           working tree should be in another branch that has nothing to do with what
           you committed previously. You can start a new branch and reset it while
           keeping the changes in your working tree.

               $ git tag start
               $ git switch -c branch1
               $ edit
               $ git commit ...                            [1m(1)[0m
               $ edit
               $ git switch -c branch2                     [1m(2)[0m
               $ git reset --keep start                    [1m(3)[0m

            [1m1. [22mThis commits your first edits in [1mbranch1[22m.
            [1m2. [22mIn the ideal world, you could have realized that the earlier
               commit did not belong to the new topic when you created and
               switched to [1mbranch2 [22m(i.e.  [1mgit switch -c branch2 start[22m), but
               nobody is perfect.
            [1m3. [22mBut you can use [1mreset --keep [22mto remove the unwanted commit
               after you switched to [1mbranch2[22m.

       Split a commit apart into a sequence of commits
           Suppose that you have created lots of logically separate changes and
           committed them together. Then, later you decide that it might be better
           to have each logical chunk associated with its own commit. You can use
           git reset to rewind history without changing the contents of your local
           files, and then successively use [1mgit add -p [22mto interactively select which
           hunks to include into each commit, using [1mgit commit -c [22mto pre-populate
           the commit message.

               $ git reset -N HEAD^                        [1m(1)[0m
               $ git add -p                                [1m(2)[0m
               $ git diff --cached                         [1m(3)[0m
               $ git commit -c HEAD@{1}                    [1m(4)[0m
               ...                                         [1m(5)[0m
               $ git add ...                               [1m(6)[0m
               $ git diff --cached                         [1m(7)[0m
               $ git commit ...                            [1m(8)[0m

            [1m1. [22mFirst, reset the history back one commit so that we remove the
               original commit, but leave the working tree with all the
               changes. The -N ensures that any new files added with [1mHEAD [22mare
               still marked so that [1mgit add -p [22mwill find them.
            [1m2. [22mNext, we interactively select diff hunks to add using the [1mgit[0m
               [1madd -p [22mfacility. This will ask you about each diff hunk in
               sequence and you can use simple commands such as "yes, include
               this", "No don‚Äôt include this" or even the very powerful "edit"
               facility.
            [1m3. [22mOnce satisfied with the hunks you want to include, you should
               verify what has been prepared for the first commit by using [1mgit[0m
               [1mdiff --cached[22m. This shows all the changes that have been moved
               into the index and are about to be committed.
            [1m4. [22mNext, commit the changes stored in the index. The [1m-c [22moption
               specifies to pre-populate the commit message from the original
               message that you started with in the first commit. This is
               helpful to avoid retyping it. The [1mHEAD@{1} [22mis a special
               notation for the commit that [1mHEAD [22mused to be at prior to the
               original reset commit (1 change ago). See [1mgit-reflog[22m(1) for
               more details. You may also use any other valid commit
               reference.
            [1m5. [22mYou can repeat steps 2-4 multiple times to break the original
               code into any number of commits.
            [1m6. [22mNow you‚Äôve split out many of the changes into their own
               commits, and might no longer use the patch mode of [1mgit add[22m, in
               order to select all remaining uncommitted changes.
            [1m7. [22mOnce again, check to verify that you‚Äôve included what you want
               to. You may also wish to verify that git diff doesn‚Äôt show any
               remaining changes to be committed later.
            [1m8. [22mAnd finally create the final commit.

[1mDISCUSSION[0m
       The tables below show what happens when running:

           git reset --option target

       to reset the [1mHEAD [22mto another commit ([1mtarget[22m) with the different reset options
       depending on the state of the files.

       In these tables, [1mA[22m, [1mB[22m, [1mC [22mand [1mD [22mare some different states of a file. For
       example, the first line of the first table means that if a file is in state [1mA[0m
       in the working tree, in state [1mB [22min the index, in state [1mC [22min [1mHEAD [22mand in state
       [1mD [22min the target, then [1mgit reset --soft target [22mwill leave the file in the
       working tree in state [1mA [22mand in the index in state [1mB[22m. It resets (i.e. moves)
       the [1mHEAD [22m(i.e. the tip of the current branch, if you are on one) to [1mtarget[0m
       (which has the file in state [1mD[22m).

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            A       B     C    D     --soft   A       B     D
                                     --mixed  A       D     D
                                     --hard   D       D     D
                                     --merge (disallowed)
                                     --keep  (disallowed)

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            A       B     C    C     --soft   A       B     C
                                     --mixed  A       C     C
                                     --hard   C       C     C
                                     --merge (disallowed)
                                     --keep   A       C     C

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            B       B     C    D     --soft   B       B     D
                                     --mixed  B       D     D
                                     --hard   D       D     D
                                     --merge  D       D     D
                                     --keep  (disallowed)

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            B       B     C    C     --soft   B       B     C
                                     --mixed  B       C     C
                                     --hard   C       C     C
                                     --merge  C       C     C
                                     --keep   B       C     C

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            B       C     C    D     --soft   B       C     D
                                     --mixed  B       D     D
                                     --hard   D       D     D
                                     --merge (disallowed)
                                     --keep  (disallowed)

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            B       C     C    C     --soft   B       C     C
                                     --mixed  B       C     C
                                     --hard   C       C     C
                                     --merge  B       C     C
                                     --keep   B       C     C

       [1mreset --merge [22mis meant to be used when resetting out of a conflicted merge.
       Any mergy operation guarantees that the working tree file that is involved in
       the merge does not have a local change with respect to the index before it
       starts, and that it writes the result out to the working tree. So if we see
       some difference between the index and the target and also between the index
       and the working tree, then it means that we are not resetting out from a
       state that a mergy operation left after failing with a conflict. That is why
       we disallow [1m--merge [22moption in this case.

       [1mreset --keep [22mis meant to be used when removing some of the last commits in
       the current branch while keeping changes in the working tree. If there could
       be conflicts between the changes in the commit we want to remove and the
       changes in the working tree we want to keep, the reset is disallowed. That‚Äôs
       why it is disallowed if there are both changes between the working tree and
       [1mHEAD[22m, and between [1mHEAD [22mand the target. To be safe, it is also disallowed when
       there are unmerged entries.

       The following tables show what happens when there are unmerged entries:

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            X       U     A    B     --soft  (disallowed)
                                     --mixed  X       B     B
                                     --hard   B       B     B
                                     --merge  B       B     B
                                     --keep  (disallowed)

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            X       U     A    A     --soft  (disallowed)
                                     --mixed  X       A     A
                                     --hard   A       A     A
                                     --merge  A       A     A
                                     --keep  (disallowed)

       [1mX [22mmeans any state and [1mU [22mmeans an unmerged index.

[1mGIT[0m
       Part of the [1mgit[22m(1) suite

Git 2.47.2                           01/13/2025                         [4mGIT-RESET[24m(1)
